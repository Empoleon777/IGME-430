{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://gifuct/webpack/bootstrap","webpack://gifuct/./src/audio.ts","webpack://gifuct/webpack/runtime/define property getters","webpack://gifuct/webpack/runtime/hasOwnProperty shorthand","webpack://gifuct/webpack/runtime/make namespace object","webpack://gifuct/./src/canvas.ts","webpack://gifuct/./src/utils.ts","webpack://gifuct/./src/main.ts","webpack://gifuct/./src/loader.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// 1 - our WebAudio context, **we will export and make this public at the bottom of the file**\r\nlet audioCtx: AudioContext;\r\n\r\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\r\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\r\nlet element: HTMLAudioElement, sourceNode: MediaElementAudioSourceNode, analyserNode: AnalyserNode, gainNode;\r\n\r\n// 3 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n    gain: 0.5,\r\n    numSamples: 256\r\n});\r\n\r\n// 4 - create a new array of 8-bit integers (0-255)\r\n// this is a typed array to hold the audio frequency data\r\nlet audioData = new Uint8Array(DEFAULTS.numSamples / 2);\r\n\r\nlet biquadFilter: BiquadFilterNode;\r\nlet lowShelfBiquadFilter: BiquadFilterNode;\r\nlet allpassFilter: BiquadFilterNode;\r\nlet bandpassFilter: BiquadFilterNode;\r\nlet peakingFilter: BiquadFilterNode;\r\n\r\nlet highshelf = false;\r\nlet lowshelf = false;\r\nlet allpass = false;\r\nlet bandpass = false;\r\nlet peaking = false;\r\nlet distortion = false;\r\n\r\n\r\nlet distortionFilter: WaveShaperNode;\r\n\r\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\r\nconst setupWebaudio = (filePath: string): void => {\r\n    // 1 - The || is because WebAudio has not been standardized across browsers yet\r\n    const AudioContext = window.AudioContext;\r\n    audioCtx = new AudioContext();\r\n\r\n    // 2 - this creates an <audio> element\r\n    element = document.querySelector(\"audio\");\r\n\r\n    // 3 - have it point at a sound file\r\n    loadSoundFile(filePath);\r\n\r\n    // 4 - create an a source node that points at the <audio> element\r\n    sourceNode = audioCtx.createMediaElementSource(element);\r\n\r\n    // 5 - create an analyser node\r\n    // note the UK spelling of \"Analyser\"\r\n    analyserNode = audioCtx.createAnalyser();\r\n\r\n    /*\r\n    // 6\r\n    We will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\n    across the sound spectrum.\r\n    \r\n    If DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\n    the third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\n    the amplitude of that frequency.\r\n    */\r\n\r\n    // fft stands for Fast Fourier Transform\r\n    analyserNode.fftSize = DEFAULTS.numSamples;\r\n\r\n    // 7 - create a gain (volume) node\r\n    gainNode = audioCtx.createGain();\r\n    gainNode.gain.value = DEFAULTS.gain;\r\n\r\n    // 8 - connect the nodes - we now have an audio graph\r\n    sourceNode.connect(analyserNode);\r\n    analyserNode.connect(gainNode);\r\n    gainNode.connect(audioCtx.destination);\r\n\r\n    biquadFilter = audioCtx.createBiquadFilter();\r\n    biquadFilter.type = \"highshelf\";\r\n\r\n    sourceNode.connect(biquadFilter);\r\n    biquadFilter.connect(analyserNode);\r\n\r\n    lowShelfBiquadFilter = audioCtx.createBiquadFilter();\r\n    lowShelfBiquadFilter.type = \"lowshelf\";\r\n\r\n    sourceNode.connect(lowShelfBiquadFilter);\r\n    lowShelfBiquadFilter.connect(analyserNode);\r\n\r\n    allpassFilter = audioCtx.createBiquadFilter();\r\n    allpassFilter.type = \"allpass\";\r\n\r\n    sourceNode.connect(allpassFilter);\r\n    allpassFilter.connect(analyserNode);\r\n\r\n    bandpassFilter = audioCtx.createBiquadFilter();\r\n    bandpassFilter.type = \"bandpass\";\r\n\r\n    sourceNode.connect(bandpassFilter);\r\n    bandpassFilter.connect(analyserNode);\r\n\r\n    peakingFilter = audioCtx.createBiquadFilter();\r\n    peakingFilter.type = \"peaking\";\r\n\r\n    sourceNode.connect(peakingFilter);\r\n    peakingFilter.connect(analyserNode);\r\n\r\n    distortionFilter = audioCtx.createWaveShaper()\r\n\r\n    sourceNode.connect(distortionFilter);\r\n    distortionFilter.connect(analyserNode);\r\n}\r\n\r\nlet distortionAmount: number = 20;\r\n\r\nconst loadSoundFile = (filePath: string): void => {\r\n    element.src = filePath;\r\n}\r\n\r\n// const playCurrentSound = () => {\r\n//     element.play();\r\n// }\r\n\r\n// const pauseCurrentSound = () => {\r\n//     element.pause();\r\n// }\r\n\r\n// const setVolume = (value) => {\r\n//     value = Number(value); // make sure that it's a Number rather than a String\r\n//     gainNode.gain.value = value;\r\n// }\r\n\r\nconst toggleHighshelf = (box: HTMLInputElement): void => {\r\n    highshelf = box.checked;\r\n\r\n    if (highshelf) {\r\n        biquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime); // we created the `biquadFilter` (i.e. \"treble\") node last time\r\n        biquadFilter.gain.setValueAtTime(25, audioCtx.currentTime);\r\n    } else {\r\n        biquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\nconst toggleLowshelf = (box: HTMLInputElement): void => {\r\n    lowshelf = box.checked;\r\n\r\n    if (lowshelf) {\r\n        lowShelfBiquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        lowShelfBiquadFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        lowShelfBiquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\nconst toggleAllpass = (box: HTMLInputElement): void => {\r\n    allpass = box.checked;\r\n\r\n    if (allpass) {\r\n        allpassFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        allpassFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        allpassFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\nconst toggleBandpass = (box: HTMLInputElement): void => {\r\n    bandpass = box.checked;\r\n\r\n    if (bandpass) {\r\n        bandpassFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        bandpassFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        bandpassFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\nconst togglePeaking = (box: HTMLInputElement): void => {\r\n    peaking = box.checked;\r\n\r\n    if (peaking) {\r\n        peakingFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        peakingFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        peakingFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\nconst toggleDistortion = (box: HTMLInputElement): void => {\r\n    distortion = box.checked;\r\n\r\n    if (distortion) {\r\n        distortionFilter.curve = null; // being paranoid and trying to trigger garbage collection\r\n        distortionFilter.curve = makeDistortionCurve(distortionAmount);\r\n    } else {\r\n        distortionFilter.curve = null;\r\n    }\r\n}\r\n\r\n// from: https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\r\nconst makeDistortionCurve = (amount: number = 20): Float32Array => {\r\n    let n_samples = 256, curve = new Float32Array(n_samples);\r\n    for (let i = 0; i < n_samples; ++i) {\r\n        let x = i * 2 / n_samples - 1;\r\n        curve[i] = (Math.PI + amount) * x / (Math.PI + amount * Math.abs(x));\r\n    }\r\n    return curve;\r\n}\r\n\r\nconst changeDistortionValue = (value: number): void => {\r\n    distortionAmount = value;\r\n}\r\n\r\n\r\n// Function to identify peaks\r\nconst getPeaksAtThreshold = (data: Array<number>, threshold: number): Array<number> => {\r\n    let peaksArray = [];\r\n    let length = data.length;\r\n    for (let i = 0; i < length;) {\r\n        if (data[i] > threshold) {\r\n            peaksArray.push(i);\r\n            // Skip forward ~ 1/4s to get past this peak.\r\n            i += 10000;\r\n        }\r\n        i++;\r\n    }\r\n    return peaksArray;\r\n}\r\n\r\nconst countIntervalsBetweenNearbyPeaks = (peaks: Array<number>): { interval: number; count: number }[] => {\r\n    let intervalCounts = [];\r\n    peaks.forEach(function (peak, index) {\r\n        for (let i = 0; i < 10; i++) {\r\n            let interval = peaks[index + i] - peak;\r\n            let foundInterval = intervalCounts.some(function (intervalCount) {\r\n                if (intervalCount.interval === interval)\r\n                    return intervalCount.count++;\r\n            });\r\n            if (!foundInterval) {\r\n                intervalCounts.push({\r\n                    interval: interval,\r\n                    count: 1\r\n                });\r\n            }\r\n        }\r\n    });\r\n    return intervalCounts;\r\n}\r\n\r\n// Function used to return a histogram of tempo candidates.\r\nconst groupNeighborsByTempo = (intervalCounts: { interval: number; count: number }[]): void => {\r\n    let tempoCounts = []\r\n    intervalCounts.forEach(function (intervalCount, i) {\r\n        // Convert an interval to tempo\r\n        let theoreticalTempo = 60 / (intervalCount.interval / 44100);\r\n\r\n        // Adjust the tempo to fit within the 90-180 BPM range\r\n        while (theoreticalTempo < 90) theoreticalTempo *= 2;\r\n        while (theoreticalTempo > 180) theoreticalTempo /= 2;\r\n\r\n        let foundTempo = tempoCounts.some(function (tempoCount) {\r\n            if (tempoCount.tempo === theoreticalTempo)\r\n                return tempoCount.count += intervalCount.count;\r\n        });\r\n        if (!foundTempo) {\r\n            tempoCounts.push({\r\n                tempo: theoreticalTempo,\r\n                count: intervalCount.count\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport { audioCtx, setupWebaudio, loadSoundFile, toggleHighshelf, toggleLowshelf, toggleAllpass, toggleBandpass, togglePeaking, toggleDistortion, makeDistortionCurve, changeDistortionValue, analyserNode, highshelf, lowshelf, allpass, bandpass, peaking, distortion, distortionAmount, getPeaksAtThreshold, countIntervalsBetweenNearbyPeaks, groupNeighborsByTempo };","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\r\n    The purpose of this file is to take in the analyser node and a <canvas> element: \r\n      - the module will create a drawing context that points at the <canvas> \r\n      - it will store the reference to the analyser node\r\n      - in draw(), it will loop through the data in the analyser node\r\n      - and then draw something representative on the canvas\r\n      - maybe a better name for this file/module would be *visualizer* ?\r\n*/\r\n\r\nimport * as utils from './utils';\r\nimport * as main from \"./main\";\r\n// import * as gifuct from './gifuct-ts/dist/';\r\n\r\ninterface DrawParams {\r\n    showBars?: boolean,\r\n    showWave?: boolean,\r\n    showCircles?: boolean,\r\n    showOgerpon?: boolean,\r\n    showInvert?: boolean,\r\n    showEmboss?: boolean,\r\n    showBackgroundCircles?: boolean,\r\n    randomizeBackgroundCircles?: boolean\r\n}\r\n\r\nlet ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number, gradient: CanvasGradient, analyserNode: AnalyserNode, audioData: Uint8Array, waveData: Uint8Array, circleList: movingCircle[], j: number, time: number, wave: soundWave;\r\nconst delay = 0.25;\r\nj = 0;\r\ntime = 0;\r\nlet frames;\r\nlet currFrame;\r\n\r\nclass movingCircle {\r\n    public ctx: CanvasRenderingContext2D;\r\n    public radius: number;\r\n    public random: boolean;\r\n    public x: number;\r\n    public y: number;\r\n    public speed: number;\r\n    public color: string;\r\n\r\n    constructor(ctx, random: boolean, speed: number) {\r\n        this.ctx = ctx;\r\n        this.radius = 1;\r\n        this.random = random;\r\n        this.x = -5;\r\n        this.y = Math.random() * canvasHeight;\r\n        this.speed = speed;\r\n        this.color;\r\n\r\n        this.changeRandom(random);\r\n    }\r\n\r\n    draw() {\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.fillStyle = this.color;\r\n        this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n        this.ctx.fill();\r\n        this.ctx.closePath();\r\n        this.ctx.restore();\r\n    }\r\n\r\n    // Translates the circle.\r\n    move(deltaTime: number): void {\r\n        this.ctx.save();\r\n        this.x += (this.speed * deltaTime) / 1000;\r\n        this.ctx.restore();\r\n    }\r\n\r\n    // Returns the circle to the start if it reaches the right edge of the canvas.\r\n    reset(speed: number): void {\r\n        this.x = 0;\r\n        this.y = Math.random() * canvasHeight;\r\n        this.speed = speed;\r\n    }\r\n\r\n    // Toggles whether the circles should be random colors.\r\n    changeRandom(random: boolean): void {\r\n        this.random = random;\r\n\r\n        if (this.random == true) {\r\n            this.color = utils.getRandomColor();\r\n        }\r\n        else {\r\n            this.color = utils.makeColor(255, 255, 255);\r\n        }\r\n    }\r\n}\r\n\r\nclass soundWave {\r\n    public ctx: CanvasRenderingContext2D;\r\n    public x: number;\r\n    public y: number;\r\n    public radius: number;\r\n    public growthRate: number;\r\n    public color: string;\r\n\r\n    constructor(ctx: CanvasRenderingContext2D, growthRate: number, color: string) {\r\n        this.ctx = ctx;\r\n        this.x = canvasWidth / 2;\r\n        this.y = canvasHeight / 2;\r\n        this.radius = 0;\r\n        this.growthRate = growthRate;\r\n        this.color = color;\r\n    }\r\n\r\n    draw = (params: DrawParams): void => {\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.strokeStyle = this.color;\r\n        this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n        this.ctx.restore();\r\n    }\r\n\r\n    expand = (deltaTime: number): void => {\r\n        this.ctx.save();\r\n        this.radius += this.growthRate * deltaTime / 100000;\r\n        this.ctx.restore();\r\n    }\r\n\r\n    // Returns the circle to the start if it reaches the right edge of the canvas.\r\n    reset = (): void => {\r\n        this.radius = 0;\r\n    }\r\n}\r\n\r\nconst setupCanvas = (canvasElement: HTMLCanvasElement, analyserNodeRef: AnalyserNode): void => {\r\n    // create drawing context\r\n    ctx = canvasElement.getContext(\"2d\");\r\n    canvasWidth = canvasElement.width;\r\n    canvasHeight = canvasElement.height;\r\n    // create a gradient that runs top to bottom\r\n    gradient = utils.getLinearGradient(ctx, 0, 0, 0, canvasHeight, [{ percent: 0, color: \"blue\" }, { percent: .25, color: \"green\" }, { percent: .5, color: \"yellow\" }, { percent: .75, color: \"red\" }, { percent: 1, color: \"magenta\" }]);\r\n    // keep a reference to the analyser node\r\n    analyserNode = analyserNodeRef;\r\n\r\n    // this is the array where the analyser data will be stored\r\n    audioData = new Uint8Array(analyserNode.fftSize / 2);\r\n    waveData = new Uint8Array(analyserNode.fftSize / 2);\r\n    circleList = [];\r\n    wave = new soundWave(ctx, 0, \"white\");\r\n\r\n    // Loading the image elements into the Canvas.\r\n    // for (let i = 0; i < 208; i++) {\r\n    //     let frameID = \"\";\r\n    //     for (let j = 1; j <= 4 - String(207 - i).length; j++) {\r\n    //         frameID += String(0);\r\n    //     }\r\n    //     frameID += String(207 - i);\r\n    //     document.querySelector(\"#display\").innerHTML += `<img src=\"./images/ogerpon-pokemon_${frameID}_Layer-${i + 1}.png\" alt=\"\" style=\"display:none\">`;\r\n    // }\r\n\r\n    // currFrame = 1;\r\n\r\n    // frames = document.querySelectorAll(\"img\");\r\n\r\n    // let gif = document.querySelector(\"img\");\r\n    // frames = gifuct.GifReader(gif);\r\n}\r\n\r\nconst draw = (params: DrawParams, deltaTime: number): void => {\r\n    // if (params.showBars) {\r\n    //     analyserNode.getByteFrequencyData(audioData);\r\n    // }\r\n    // else if (params.showWave) {\r\n    //     analyserNode.getByteTimeDomainData(audioData)\r\n    // }\r\n\r\n    analyserNode.getByteFrequencyData(audioData);\r\n    analyserNode.getByteTimeDomainData(waveData);\r\n\r\n    // OR\r\n    //analyserNode.getByteTimeDomainData(audioData); // waveform data\r\n\r\n    // 2 - draw background\r\n    ctx.save();\r\n    ctx.fillStyle = \"black\";\r\n    ctx.globalAlpha = 0.5;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.restore();\r\n\r\n    if (params.showBackgroundCircles && main.playing == true) {\r\n        for (let i = 0; i < circleList.length; i++) {\r\n            circleList[i].speed = audioData[i];\r\n\r\n            if (circleList[i].speed == 0) {\r\n                circleList[i].speed = 10;\r\n            }\r\n\r\n            circleList[i].move(deltaTime);\r\n            circleList[i].draw();\r\n\r\n            if (circleList[i].x >= canvasWidth) {\r\n                circleList[i].reset(audioData[j]);\r\n                j++;\r\n\r\n                if (j >= audioData.length || audioData[j] == 0) {\r\n                    j = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // if (params.showOgerpon && main.playing == true) {\r\n    //     ctx.globalAlpha = 1;\r\n    //     let leftIndex = currFrame - 1;\r\n    //     let rightIndex = 207 - leftIndex;\r\n    //     ctx.drawImage(frames[leftIndex], canvasWidth / 8, canvasHeight / 4, canvasWidth / 2, canvasHeight / 2);\r\n    //     ctx.drawImage(frames[rightIndex], 5 * canvasWidth / 8, canvasHeight / 4, canvasWidth / 2, canvasHeight / 2);\r\n\r\n    // }\r\n\r\n    // // 3 - draw gradient\r\n    // if (params.showGradient) {\r\n    //     ctx.save();\r\n    //     ctx.fillStyle = gradient;\r\n    //     ctx.globalAlpha = 0.3;\r\n    //     ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    //     ctx.restore();\r\n    // }\r\n\r\n    // 4 - draw bars\r\n    if (params.showBars) {\r\n        let margin = 5;\r\n        let screenWidthForBars = canvasWidth - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let barHeight;\r\n        let topSpacing = 100;\r\n\r\n        ctx.save();\r\n\r\n        // Loop through the data and draw.\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            ctx.fillStyle = `rgba(${audioData[i]},0,${255 - audioData[i]},1)`;\r\n            ctx.strokeStyle = 'rgba(255,255,255,0.2)';\r\n            barHeight = audioData[i] + 100;\r\n            ctx.fillRect(margin + i * barWidth, canvasHeight + 10, barWidth / 10, (-barHeight - 10) / 2);\r\n            ctx.strokeRect(margin + i * barWidth, canvasHeight + 10, barWidth / 10, (-barHeight - 10) / 2);\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    if (params.showWave) {\r\n        let pointSpacing = canvasWidth / waveData.length;\r\n        let topSpacing = 100;\r\n        let margin = 5;\r\n\r\n        ctx.save();\r\n        ctx.strokeStyle = 'rgba(255,255,255,1)';\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n\r\n        // Loop through the data.\r\n        // for (let i = 1; i < audioData.length; i += 2) {\r\n        //     ctx.moveTo((i - 1) * pointSpacing, audioData[i - 1]);\r\n        //     ctx.quadraticCurveTo((i) * pointSpacing, audioData[i], (i + 1) * pointSpacing, audioData[i + 1]);\r\n        // }\r\n\r\n        ctx.moveTo(0, topSpacing + 256 - (canvasHeight / 2));\r\n\r\n        for (let i = 0; i < waveData.length; i++) {\r\n            ctx.lineTo(i * pointSpacing + margin, topSpacing + 256 - (waveData[i] / 128.0) * (canvasHeight / 2));\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    // 5 - draw circles\r\n    if (params.showCircles && main.playing == true) {\r\n        let maxRadius = canvasHeight / 4;\r\n        ctx.save();\r\n        ctx.globalAlpha = 0.5;\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            let percent = audioData[i] / 255;\r\n\r\n            if (time <= 0) {\r\n                if (wave.growthRate == 0) {\r\n                    wave.growthRate = audioData[i] * 2;\r\n                }\r\n\r\n                wave.draw(params);\r\n                wave.expand(deltaTime);\r\n\r\n                if (wave.radius > canvasWidth / 2 * 1.5) {\r\n                    wave.growthRate = 0;\r\n                    wave.reset();\r\n                    time = delay;\r\n                }\r\n\r\n            }\r\n            else {\r\n                time -= deltaTime / 1000;\r\n            }\r\n\r\n            // // red-ish circles\r\n            // let circleRadius = percent * maxRadius;\r\n            // ctx.beginPath();\r\n            // ctx.fillStyle = utils.makeColor(255, 111, 111, 0.34 - percent / 3.0);\r\n            // ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius, 0, 2 * Math.PI, false);\r\n            // ctx.fill();\r\n            // ctx.closePath();\r\n\r\n            // // blue-ish circles, bigger, more transparent\r\n            // ctx.beginPath();\r\n            // ctx.fillStyle = utils.makeColor(0, 0, 255, 0.10 - percent / 10.0);\r\n            // ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 1.5, 0, 2 * Math.PI, false);\r\n            // ctx.fill();\r\n            // ctx.closePath();\r\n\r\n            // // yellow-ish circles, smaller\r\n            // ctx.save();\r\n            // ctx.beginPath();\r\n            // ctx.fillStyle = utils.makeColor(200, 200, 0, 0.5 - percent / 5.0);\r\n            // ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 0.50, 0, 2 * Math.PI, false);\r\n            // ctx.fill();\r\n            // ctx.closePath();\r\n            // ctx.restore();\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    // 6 - bitmap manipulation\r\n    // TODO: right now. we are looping though every pixel of the canvas (320,000 of them!), \r\n    // regardless of whether or not we are applying a pixel effect\r\n    // At some point, refactor this code so that we are looping though the image data only if\r\n    // it is necessary\r\n\r\n    // A) grab all of the pixels on the canvas and put them in the `data` array\r\n    // `imageData.data` is a `Uint8ClampedArray()` typed array that has 1.28 million elements!\r\n    // the variable `data` below is a reference to that array \r\n    let imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\r\n    let data = imageData.data;\r\n    let length = data.length;\r\n    let width = imageData.width; // Not used here\r\n\r\n    // B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\r\n    for (let i = 0; i < length; i += 4) {\r\n        // // C) randomly change every 20th pixel to red\r\n        // if (params.showNoise && Math.random() < 0.05) {\r\n        //     // data[i] is the red channel\r\n        //     // data[i+1] is the green channel\r\n        //     // data[i+2] is the blue channel\r\n        //     // data[i+3] is the alpha channel\r\n        //     data[i] = data[i + 1] = data[i + 2] = 0;// zero out the red and green and blue channels\r\n        //     data[i] = 255;// make the red channel 100% red\r\n        // } // end if\r\n        if (params.showInvert) {\r\n            let red = data[i], green = data[i + 1], blue = data[i + 2];\r\n            data[i] = 255 - red;\r\n            data[i + 1] = 255 - green;\r\n            data[i + 2] = 255 - blue;\r\n            // data[i+3] is the alpha channel, but we're leaving that alone.\r\n        }\r\n    } // end for\r\n\r\n    if (params.showEmboss) {\r\n        // We're stepping through every sub-pixel.\r\n        for (let i = 0; i < length; i++) {\r\n            if (i % 4 == 3) continue; // Skip alpha channel\r\n            data[i] = 127 + 2 * data[i] - data[i + 4] - data[i + width * 4];\r\n        }\r\n    }\r\n\r\n    // D) copy image data back to canvas\r\n    ctx.putImageData(imageData, 0, 0);\r\n}\r\n\r\nconst setJIndex = (value: number): void => {\r\n    j = value;\r\n}\r\n\r\nexport { setupCanvas, draw, setJIndex, audioData, circleList, movingCircle, j, ctx };","interface ColorStop {\r\n  percent: number;\r\n  color: string;\r\n}\r\n\r\nconst makeColor = (red: number, green: number, blue: number, alpha: number = 1): string => {\r\n  return `rgba(${red},${green},${blue},${alpha})`;\r\n};\r\n\r\nconst getRandom = (min: number, max: number): number => {\r\n  return Math.random() * (max - min) + min;\r\n};\r\n\r\nconst getRandomColor = (floor: number = 35): string => {\r\n  const getByte = () => getRandom(floor, 255 - floor);\r\n  return `rgba(${getByte()},${getByte()},${getByte()},1)`;\r\n};\r\n\r\nconst getLinearGradient = (ctx: CanvasRenderingContext2D, startX: number, startY: number, endX: number, endY: number, colorStops: ColorStop[]) => {\r\n  let lg = ctx.createLinearGradient(startX, startY, endX, endY);\r\n  for (let stop of colorStops) {\r\n    lg.addColorStop(stop.percent, stop.color);\r\n  }\r\n  return lg;\r\n};\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\r\nconst goFullscreen = (element): void => {\r\n  if (element.requestFullscreen) {\r\n    element.requestFullscreen();\r\n  } else if (element.mozRequestFullscreen) {\r\n    element.mozRequestFullscreen();\r\n  } else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec\r\n    element.mozRequestFullScreen();\r\n  } else if (element.webkitRequestFullscreen) {\r\n    element.webkitRequestFullscreen();\r\n  }\r\n  // .. and do nothing if the method is not supported\r\n};\r\n\r\nexport { makeColor, getRandom, getRandomColor, getLinearGradient, goFullscreen };","/*\r\n    main is primarily responsible for hooking up the UI to the rest of the application \r\n    and setting up the main event loop\r\n*/\r\n\r\nimport * as audio from './audio';\r\nimport * as canvas from './canvas';\r\n\r\n// We will write the functions in this file in the traditional ES5 way\r\n// In this instance, we feel the code is more readable if written this way\r\n// If you want to re-write these as ES6 arrow functions, to be consistent with the other files, go ahead!\r\n\r\nimport * as utils from './utils';\r\n\r\nlet canvasModule: typeof canvas = canvas;\r\n\r\nconst drawParams = {\r\n    showBars: true,\r\n    showWave: false,\r\n    showCircles: true,\r\n    showOgerpon: true,\r\n    showInvert: false,\r\n    showEmboss: false,\r\n    showBackgroundCircles: true,\r\n    randomizeBackgroundCircles: true\r\n}\r\n\r\nlet lastTime: number;\r\nlet currTime: number;\r\nlet deltaTime: number;\r\nlet playing: boolean;\r\n\r\n// 1 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n    sound1: \"media/New Adventure Theme.mp3\"\r\n});\r\n\r\nconst init = (): void => {\r\n    audio.setupWebaudio(DEFAULTS.sound1);\r\n    console.log(\"init called\");\r\n    console.log(`Testing utils.getRandomColor() import: ${utils.getRandomColor()}`);\r\n    let canvasElement = document.querySelector(\"canvas\"); // hookup <canvas> element\r\n    setupUI(canvasElement);\r\n    canvasModule.setupCanvas(canvasElement, audio.analyserNode);\r\n    for (let i = 0; i < canvasModule.audioData.length; i++) {\r\n        canvasModule.circleList.push(new canvasModule.movingCircle(canvasModule.ctx, drawParams.showBackgroundCircles, canvasModule.audioData[i]));\r\n    }\r\n    lastTime = performance.now();\r\n    loop();\r\n}\r\n\r\nconst setupUI = (canvasElement: HTMLCanvasElement): void => {\r\n    // A - hookup fullscreen button\r\n    const fsButton = document.querySelector(\"#fs-button\") as HTMLButtonElement;\r\n\r\n    // add .onclick event to button\r\n    fsButton.onclick = e => {\r\n        console.log(\"goFullscreen() called\");\r\n        utils.goFullscreen(canvasElement);\r\n    };\r\n\r\n    // Hook up the play button.\r\n    // const playButton = document.querySelector(\"#play-button\");\r\n\r\n    // // add .onclick event to button\r\n    // playButton.onclick = e => {\r\n    //     console.log(`audioCtx.state before = ${audio.audioCtx.state}`);\r\n\r\n    //     // check if context is in suspended state (autoplay policy)\r\n    //     if (audio.audioCtx.state == \"suspended\") {\r\n    //         audio.audioCtx.resume();\r\n    //     }\r\n    //     console.log(`audioCtx.state after = ${audio.audioCtx.state}`);\r\n    //     if (e.target.dataset.playing == \"no\") {\r\n    //         // If the track is paused, play it.\r\n    //         audio.playCurrentSound();\r\n    //         e.target.dataset.playing = \"yes\"; // Our CSS sets the text to \"Pause.\"\r\n    //     }\r\n    //     else {\r\n    //         audio.pauseCurrentSound();\r\n    //         e.target.dataset.playing = \"no\"; // Our CSS sets the text to \"Pause.\"\r\n    //     }\r\n\r\n    //     playing = e.target.dataset.playing;\r\n    // };\r\n\r\n    // // C - Hookup volume slider & label\r\n    // let volumeSlider = document.querySelector(\"#volume-slider\");\r\n    // let volumeLabel = document.querySelector(\"#volume-label\");\r\n\r\n    // // Add .oninput event to slider.\r\n    // volumeSlider.oninput = e => {\r\n    //     // Set the gain\r\n    //     audio.setVolume(e.target.value);\r\n    //     // Update value of label to match value of slider\r\n    //     volumeLabel.innerHTML = Math.round((e.target.value / 2 * 100));\r\n    // };\r\n\r\n    // volumeSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n    // D - Hookup track <select>\r\n    let trackSelect = document.querySelector(\"#track-select\") as HTMLSelectElement;\r\n    loadJSONData(trackSelect);\r\n\r\n    let audioControls = document.querySelector(\"audio\") as HTMLAudioElement;\r\n\r\n    // add .onchange event to <select>\r\n    trackSelect.onchange = e => {\r\n        const target = e.target as HTMLSelectElement;\r\n        audio.loadSoundFile(target.value);\r\n        audioControls.src = trackSelect.value;\r\n    }\r\n\r\n    audioControls.src = \"media/New Adventure Theme.mp3\";\r\n\r\n    audioControls.onplay = (e) => {\r\n        if (audio.audioCtx.state == \"suspended\") {\r\n            audio.audioCtx.resume();\r\n        }\r\n\r\n        playing = true;\r\n    };\r\n\r\n    audioControls.onpause = (e) => {\r\n        playing = false\r\n    }\r\n\r\n    // E - Set up the controls\r\n    let radioButtons = document.querySelectorAll<HTMLInputElement>('input[name=\"display-type\"]');\r\n    let circlesBox = document.querySelector(\"#circles-cb\") as HTMLButtonElement;\r\n    let ogerponBox = document.querySelector(\"#ogerpon-cb\") as HTMLButtonElement;\r\n    let invertBox = document.querySelector(\"#invert-cb\") as HTMLButtonElement;\r\n    let embossBox = document.querySelector(\"#emboss-cb\") as HTMLButtonElement;\r\n    let bCirclesBox = document.querySelector(\"#b-circles-cb\") as HTMLButtonElement;\r\n    let randomizerBox = document.querySelector(\"#randomize-cb\") as HTMLButtonElement;\r\n    let circleInput = document.querySelector(\"#circles-input\") as HTMLButtonElement;\r\n\r\n    radioButtons[0].onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showBars = target.checked;\r\n        if (drawParams.showWave == true) {\r\n            drawParams.showWave = false;\r\n        } else {\r\n            drawParams.showWave = true;\r\n        }\r\n    };\r\n\r\n    radioButtons[1].onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showWave = target.checked;\r\n        if (drawParams.showBars == true) {\r\n            drawParams.showBars = false;\r\n        } else {\r\n            drawParams.showBars = true;\r\n        }\r\n    };\r\n\r\n    circlesBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showCircles = target.checked;\r\n    }\r\n\r\n    ogerponBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showOgerpon = target.checked;\r\n    }\r\n\r\n    invertBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showInvert = target.checked;\r\n    }\r\n\r\n    embossBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showEmboss = target.checked;\r\n    }\r\n\r\n    bCirclesBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.showBackgroundCircles = target.checked;\r\n        for (let i = 0; i < canvasModule.circleList.length; i++) {\r\n            canvasModule.circleList[i].reset(canvasModule.audioData[i]);\r\n        }\r\n        canvasModule.setJIndex(0);\r\n    }\r\n\r\n    randomizerBox.onclick = function (e) {\r\n        const target = e.target as HTMLInputElement;\r\n        drawParams.randomizeBackgroundCircles = target.checked;\r\n        for (let i = 0; i < canvasModule.circleList.length; i++) {\r\n            canvasModule.circleList[i].changeRandom(drawParams.randomizeBackgroundCircles);\r\n        }\r\n    }\r\n\r\n    circleInput.onchange = function (e) {\r\n        const target = e.target as HTMLSelectElement;\r\n        for (let i = 0; i < canvasModule.circleList.length; i++) {\r\n            canvasModule.circleList[i].radius = Number(target.value);\r\n        }\r\n    }\r\n\r\n    // I. set the initial state of the high shelf checkbox\r\n    let highshelf = document.querySelector('#cb-highshelf') as HTMLInputElement;\r\n    highshelf.checked = audio.highshelf;\r\n\r\n    // II. change the value of `highshelf` every time the high shelf checkbox changes state\r\n    highshelf.onchange = e => {\r\n        audio.toggleHighshelf(highshelf);\r\n    };\r\n\r\n    // III. \r\n    audio.toggleHighshelf(highshelf);\r\n\r\n\r\n    let lowshelf = document.querySelector('#cb-lowshelf') as HTMLInputElement;\r\n    lowshelf.checked = audio.lowshelf;\r\n\r\n    lowshelf.onchange = e => {\r\n        audio.toggleLowshelf(lowshelf);\r\n    };\r\n\r\n    audio.toggleLowshelf(lowshelf);\r\n\r\n    let allpass = document.querySelector('#cb-allpass') as HTMLInputElement;\r\n    allpass.checked = audio.allpass;\r\n\r\n    allpass.onchange = e => {\r\n        audio.toggleAllpass(allpass);\r\n    };\r\n\r\n    audio.toggleAllpass(allpass);\r\n\r\n\r\n    let bandpass = document.querySelector('#cb-bandpass') as HTMLInputElement;\r\n    bandpass.checked = audio.bandpass;\r\n\r\n    bandpass.onchange = e => {\r\n        audio.toggleBandpass(bandpass);\r\n    };\r\n\r\n    audio.toggleBandpass(bandpass);\r\n\r\n    let peaking = document.querySelector('#cb-peaking') as HTMLInputElement;\r\n    peaking.checked = audio.peaking;\r\n\r\n    peaking.onchange = e => {\r\n        audio.togglePeaking(peaking);\r\n    };\r\n\r\n    audio.togglePeaking(peaking);\r\n\r\n    let distortionSlider = document.querySelector('#slider-distortion') as HTMLInputElement;\r\n    let distortion = document.querySelector('#cb-distortion') as HTMLInputElement;\r\n\r\n    distortionSlider.value = audio.distortionAmount.toString();\r\n\r\n    distortionSlider.onchange = e => {\r\n        const target = e.target as HTMLSelectElement;\r\n        audio.changeDistortionValue(Number(target.value));\r\n        audio.toggleDistortion(distortion);\r\n    };\r\n\r\n    distortion.checked = audio.distortion;\r\n\r\n    distortion.onchange = e => {\r\n        audio.toggleDistortion(distortion);\r\n    };\r\n} // end setupUI\r\n\r\nlet loadJSONData = (trackSelect: HTMLSelectElement): void => {\r\n    const url = \"data/av-data.json\";\r\n    const xhr = new XMLHttpRequest();\r\n\r\n    xhr.onload = (e) => {\r\n        let xhr = e.target as XMLHttpRequest;\r\n        const text = xhr.responseText;\r\n        // A message is printed to the console on success.\r\n        console.log(`Success - The file length is ${text.length}`);\r\n        // Our tsON is parsed into an array.\r\n        let data = JSON.parse(xhr.responseText);\r\n\r\n        document.querySelector(\"title\").innerHTML = data.title;\r\n\r\n        if (data.songs && Array.isArray(data.songs)) {\r\n            trackSelect.innerHTML = `${data.songs.map(s => `<option value=\"${s.value}\">${s.name}</option>`).join(\"\")}`;\r\n            trackSelect.value = \"media/New Adventure Theme.mp3\";\r\n        }\r\n\r\n        for (let i = 0; i < data.parameters.length; i++) {\r\n            drawParams[i] = data.parameters[i];\r\n        }\r\n    }\r\n\r\n    xhr.onerror = (e) => {\r\n        console.log(\"An error occurred.\");\r\n    }\r\n\r\n    xhr.open(\"GET\", url);\r\n    xhr.send();\r\n}\r\n\r\nconst loop = (): void => {\r\n    /* NOTE: This is temporary testing code that we will delete in Part II */\r\n    setTimeout(loop, 1000 / 60);\r\n    currTime = performance.now();\r\n    deltaTime = currTime - lastTime;\r\n    canvasModule.draw(drawParams, deltaTime);\r\n    lastTime = currTime;\r\n}\r\n\r\nexport { init, playing };","import * as main from \"./main\";\r\nwindow.onload = (): void => {\r\n\tconsole.log(\"window.onload called\");\r\n\t// 1 - do preload here - load fonts, images, additional sounds, etc...\r\n\r\n\t// 2 - start up app\r\n\tmain.init();\r\n}"],"names":["audioCtx","sourceNode","analyserNode","gainNode","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","biquadFilter","lowShelfBiquadFilter","allpassFilter","bandpassFilter","peakingFilter","distortionFilter","ctx","canvasWidth","canvasHeight","waveData","circleList","j","time","wave","DEFAULTS","freeze","gain","numSamples","Uint8Array","distortionAmount","loadSoundFile","filePath","src","toggleHighshelf","box","checked","frequency","setValueAtTime","currentTime","toggleLowshelf","toggleAllpass","toggleBandpass","togglePeaking","toggleDistortion","curve","makeDistortionCurve","amount","Float32Array","i","x","Math","PI","abs","getRandomColor","floor","getByte","min","max","random","lastTime","currTime","deltaTime","playing","speed","this","radius","y","color","changeRandom","draw","save","beginPath","fillStyle","arc","fill","closePath","restore","move","reset","alpha","growthRate","params","lineWidth","strokeStyle","stroke","expand","setupCanvas","canvasElement","analyserNodeRef","getContext","width","height","startX","startY","endX","endY","colorStops","lg","createLinearGradient","percent","addColorStop","fftSize","soundWave","getByteFrequencyData","getByteTimeDomainData","globalAlpha","fillRect","showBackgroundCircles","length","showBars","barWidth","margin","barHeight","topSpacing","strokeRect","showWave","pointSpacing","moveTo","lineTo","showCircles","imageData","getImageData","data","showInvert","red","green","blue","showEmboss","putImageData","setJIndex","canvasModule","drawParams","showOgerpon","randomizeBackgroundCircles","sound1","setupUI","document","querySelector","onclick","e","element","console","log","requestFullscreen","mozRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","trackSelect","loadJSONData","audioControls","onchange","target","onplay","state","resume","onpause","radioButtons","querySelectorAll","circlesBox","ogerponBox","invertBox","embossBox","bCirclesBox","randomizerBox","circleInput","audioData","Number","highshelf","lowshelf","allpass","bandpass","peaking","distortionSlider","distortion","toString","xhr","XMLHttpRequest","onload","text","responseText","JSON","parse","innerHTML","title","songs","Array","isArray","map","s","name","join","parameters","onerror","open","send","loop","setTimeout","performance","now","window","AudioContext","createMediaElementSource","createAnalyser","createGain","connect","destination","createBiquadFilter","type","createWaveShaper","push","movingCircle"],"sourceRoot":""}